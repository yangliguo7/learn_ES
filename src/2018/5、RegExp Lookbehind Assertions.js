/*
 * @description 正则向后断言
 * @link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions
 */

// 向后断言是新增的功能，之前是有断言功能的像向前断言

// 什么是断言
// 断言(assertion)是一种在程序中的一阶逻辑
// (如：一个结果为真或假的逻辑判断式)，目的为了表示与验证软件开发者预期的结果——当程序执行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止执行，并给出错误信息。

// 断言写法 断言是下面的(?(=|!)y)或者(?<(=|!)y)
// 前置断言 x(?(=|!)y) x需要在断言之前所以是向前断言 匹配模式是从左向右的
// x(?=exp) 例如 /\d(?=aaa)/ 表示所在位置右侧能够匹配exp  该正则表示先匹配到\d然后再看后面有没有aaa有aaa则满足正则
// x(?!exp) 例如 /\d(?!aaa)/ 表示所在位置右侧不能匹配exp  该正则表示先匹配到\d然后再看后面有没有aaa没有aaa则满足正则
// 后置断言 (?<(=|!)y)x x需要在断言之后所以是向后断言 匹配模式是从右向左的
// (?<=exp)x 例如 /(?<=aaa)\d/ 表示所在位置左侧能够匹配exp 该正则表示先匹配到\d然后向做发现断言先确保一个a然后在确保第二个a，向左进行
// (?<!exp)x 例如 /(?<!aaa)\d/ 表示所在位置左侧不能匹配exp 同理

// 例子：
// 1、前置断言
//  1.1 向前断言
let reg = /\d(?=(aaa|bbb))/g; // 匹配数字前面有aaa或者bbb这个断言
let str = '1aaa|2bbb|3ccc|4ddd';
str.match(reg); // ['1', '2'] // 注意这里的输出是不包含断言的，断言只会用作条件

//  1.2 向前否定断言
reg = /\d(?!(aaa|bbb))/g; // 匹配数字前面没有aaa或者bbb这个断言；如果写成/\d(?!=(aaa|bbb))/g 则表示匹配数字后面没=aaa或者=bbb
str = '1aaa|2bbb|3ccc|4ddd';
str.match(reg); // ['3', '4']

// 2、后置断言
//  2.1 向后断言
reg = /(?<=(aaa|bbb))\d/g;
str = 'aaa1|bbb2|ccc3|ddd4';
str.match(reg); // ['1', '2']

//  2.2 向后否定断言
reg = /(?<!(aaa|bbb))\d/g;
str = 'aaa1|bbb2|ccc3|ddd4';
str.match(reg); // ['3', '4']

// 扩展
// 1、向后断言特性是Greediness
// 例子：
str = '12345'; // + 表示一次或者多次
const reg1 = /^(?<g1>\d+)(?<g2>\d+)$/;
const reg2 = /(?<=(?<g1>\d+)(?<g2>\d+))(?<g3>\d+)$/;
const reg3 = /(?<=(?<g1>\d+)(?<g2>\d+))$/;
const reg4 = /(?<g1>\d+)(?=(?<g2>\d+)(?<g3>\d+))/;
const reg5 = /(?=(?<g1>\d+)(?<g2>\d+))$/;
str.match(reg1); // [ g1 , g2 ] ===> ['1234','5']  // 从左向右执行，左侧(g1)的组会匹配更多的字符串
str.match(reg2); // [ g1 , g2 , g3] ===> ['1','2','345']
// 向后断言是贪婪的,从右向左执行，右侧(g2)的组会匹配更多的字符串
str.match(reg3); // [g1 , g2 ] ===> ['1','2345']
str.match(reg4); // [ g1 , g2 , g3] ===> ['123','4','5']
str.match(reg5); // [g1 , g2 ] ===> ['1234','5']

// 2、向后断言里是从右到左执行的
// 例子
'12345'.match(/(?<=(?<g1>\d+)(?<g2>\d+))$/); // [ g1 , g2 ] ===> ['1','2345'] 整个是一个向后断言，
// 如果使用反向引用时也是一样
'hodor'.match(/(?<=(o)d\1)r/); // null 因为是从右往左 所以代码执行 r -> o 发现不匹配
'hodor'.match(/(?<=\1d(o))-r/); // ['r', 'o'] r -> o -> d ->o
